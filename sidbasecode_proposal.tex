\documentclass[10pt]{article}
\usepackage{cite}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{lipsum}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage[font=small]{caption}
\addtolength{\abovecaptionskip}{-3mm}
\addtolength{\textfloatsep}{-5mm}
\setlength\columnsep{20pt}

\usepackage[a4paper,left=1.50cm, right=1.50cm, top=1.50cm, bottom=1.50cm]{geometry}

\author{Josh Bailey <josh@vandervecken.com>}

\title{Sequencing the Chiptune Genome}

\begin{document}

        \begin{center}
          {\Large \textbf{Sequencing the Chiptune Genome}}\\
                \vspace{1em}
                Proposal for Thesis\\
                \vspace{1em}
                \textit{
                Ph.D. Student (Music) - Josh Bailey,
                Student Number: 300665818\\
                  New Zealand School of Music—Te Kōkī,
                  Victoria University of Wellington}\\
                \vspace{1em}
                Supervisors\\
                \vspace{1em}
                \textit{
                  Jim Murphy, Victoria University of Wellington\\
                  Dugal McKinnon, Victoria University of Wellington\\
                  Tom White, Victoria University of Wellington}\\
        \end{center}

        \begin{center}
                \rule{150mm}{0.2mm}
        \end{center}

       \begin{abstract}
The Chiptune musical genre (encompassing the sonic aesthetic of early synthesizers and personal computers) is closely connected with the Demoscene, which is an international cultural movement that prizes the competitive and creative realization of new capabilities (in the form of audiovisual performances) using constrained obsolete computers such as the Commodore 64. The Demoscene continues to the present day with regular Demoparties (live events) where innovators demonstrate their discoveries and are recognized for their artistic and technical skill.

Because these obsolete machines are so constrained, very detailed technical knowledge of them is required to identify and exploit capabilities not anticipated by their designers. These capabilities might include the production of complex new audio waveforms from sound hardware not designed to produce them, or fast digital video animation on systems with very small amounts of memory (64KB or less) compared with today’s systems. Performances are often realized as complete machine code programs built byte by byte, by hand, making use of every last CPU cycle available.

The Demoscene therefore has its own history of innovation and culture of competitively producing and building upon past innovations. Demoscene culture continues to be studied ethnographically, and shares with the computer security industry an approach to exploration and exploitation of unintended or undocumented aspects of computer architectures.

This research builds on these cultural themes and prior studies with a computational musicological analysis of a subset of musical performances (as Commodore 64 machine code programs, from Internet accessible community databases), identifying and cataloging the many technical innovations (in the form of machine code that produces unique timbres). The research aims to attribute innovations to authors and groups where possible, tracing the origination, sharing and evolution of techniques over time, with the metaphor of code and its reuse as DNA. While it is proposed not to use machine learning to achieve this, it may be possible to apply techniques including Sparse Autoencoders subject to compliance and regulatory constraints (see below).

Once complete, this analysis will provide the community with an attributed catalog of expressive techniques backed by an reproducible, transparent algorithmic approach (important to the community as a fundamental operating principle of the community is fair, peer recognition of innovation).

The research also aims to produce tools that support further exploration of the Commodore 64 platform, and new performances building on techniques discovered (including interfacing original SID hardware with modern Digital Audio Workstation software without sacrificing the expressibility gained with direct register manipulation).
         \end{abstract}

        \begin{center}
                \rule{150mm}{0.2mm}
        \end{center}

        \vspace{5mm}

\begin{multicols*}{2}

  \section{Introduction}
  At first glance musicological analysis of Commodore 64 music might
  appear trivial as the hardware is simple, well documented, and was
  designed in the late 1970s. Despite this simplicity, the
  Commodore 64 computer contained an advanced (for the time) synthesizer
  called the Sound Interface Device or SID chip. This chip has features
  recognizable in commodity synthesizers today - multiple voices and
  waveforms, and software controllable filters. Competitive
  exploration of the chip (and the Commodore 64's) creative capabilities
  continues today within an international community known as the Demoscene,
  which prizes innovation within the tight computing contraints. It is this
  evolution of innovation that is the analysis' primary focus.

  SID chip programming involves sequences of changes to memory
  registers at controlled intervals. These sequences are analogous to
  DNA - a given performance will include sequences programmed by a
  composer, either of their own invention (including re-sequencing
  from another performance that might use similar patches), or
  sequences recovered from the work of others.

  These ``DNA'' sequences can then be indexed across all known
  performances, allowing for variation (both variations that produce
  the same audio output, and variations that produce slightly or
  vastly different output depending on the precise order in which they
  are executed). Also like DNA, these sequences can be recombined and
  edited to produce new sequences, compared between sequences, and a
  given subsequence's effect on audio output can be determined.

  The proposal aims to make a systematic study of all known SID
  programming sequences (as represented in the High Voltage SID
  Collection - see below), which will include methods for identifying
  the same or similar programming techniques across all
  performances. Since the HVSC collection includes composer names and dates
  for most performances, it will be possible to realize an
  evolutionary timeline of techniques.

  Machine learning classification technology is instrumental and will
  form the basis of the analysis. While the goal of this research is a
  musicological, inevitably the potential for the same machine
  learning technology to create performances is realized. The proposal
  will necessarily engage with this possibility to demonstrate the
  practicality of identifying the original performances in the tools'
  training set. The goal is to identify techniques in all performances
  whether directly from human composers or indirectly via generative
  tools.  As the machine learning field rapidly advances, throughout
  the research there will be enagement with the Centre for Data
  Science and Artificial Intelligence Te Whiri Kawe among others.

  \section{Background}

  \subsection{Contemporaneous platforms}
  The Commodore 64 is not the only platform of the period, but is
  chosen because it is unique in its expressibility for the time and
  having significant capabilities built in without the user having to
  add additional hardware. For example, a competing platform of the
  period was the ZX Spectrum. This system had only a built in
  ``beep''er speaker with no filters or additional waveforms (though
  additional hardware was available adding among other features
  FM synthesis). The NES platform, like the SID chip had multiple
  waveforms and voices, but no filters.

  \subsection{SID players}
  A Commodore 64 musical performance is mostly commonly realized as a
  machine language program that programs the SID chip, packaged as a
  SID file. To hear a performance a complete Commodore 64 environment
  (or an emulated environment) therefore is necessary. A SID player
  executes a SID file (typically in an emulator within the player,
  including an emulated SID chip or chips), producing audio samples.
  The VICE emulator includes a SID player, which includes diagnostic
  logging of all commands sent to the SID chip.

  \subsection{High Voltage SID Collection}
  The High Voltage SID collection is a large, community curated
  collection of SID files including metadata attributing composer
  and release date, all in a machine readable format. At the time
  of writing the collection includes over 58,000 songs.

  The collection also contains some performances which have not
  yet been attributed to a composer. It is proposed to develop tools
  can analyze these performances (or indeed any new performance) and
  determine the similarity of the techniques used to other
  performances (in other words, suggesting a likely composer, or the
  composers used in the training set of a generative music system).

  \subsection{Machine code and original hardware}
  Given the lack of built in sound software in the Commodore 64, the
  SID chip can only be fully utilized with 6502 machine code, and the
  chip exhibits significant performance differences (see following)
  even within units of the same model number and revision.  While
  several software and hardware emulations of the SID chip exist, the
  behavior original hardware has proven difficult to reproduce exactly
  and emulator defects continue to be discovered.  Therefore analysis
  must include not only methods to work with original hardware, but
  original machine code as well.

  \subsection{Demoscene}
  The international Demoscene is a cultural construct, often associated
  with retrocomputing platforms, where participants regularly and
  competitively explore and push the envelope of capabilities of obsolete
  hardware, often to achieve visual or audio effects not anticipated
  by the original manufacturers. The Demoscene is often organized around
  particular computing platforms (such as the Commodore 64), and also
  competitive areas (such as producing performances using as little
  computer memory as possible). Collaboration between contributors is
  common and recognition of a contributor or groups' discovery of a new
  technique is highly prized. While the Demoscene is more a movement
  that a formal organization, there are more structured Demoparties by
  various parts of the scene (such as the X party, held annually),
  associated with cultural gatekeepers.

  \subsection{Generative synthesis}
  There is recent work in generative synthesis, for example in
  predicting new patch parameters or waveforms for modular
  synthesizers.  While this work involves machine learning prediction
  of audio samples (unlike this research which involves the
  identification and prediction of SID register state, which leads to
  audio samples), there is a shared focus on the role of patch
  parameter prediction.  A research outcome therefore may be
  a SID generative synthesizer tool that permutes initial
  SID register state in a creative direction guided by a composer
  (for example, altering a snare drum patch over time).

  \subsection{Role of machine learning}
  The field of machine learning has made rapid advances in the past
  few years and it is anticipated that it will continue to
  rapidly. Therefore, the research will be divided into two loosely
  coupled logistical tracks, musicological research and tool
  development.

  Tool development will be based on machine learning and
  analysis frameworks such as pyTorch and Pandas, so that new
  capabilities can be rapidly integrated with research as they become
  available. As musicology is the primary focus of the research,
  use of machine learning technologies will be constrained to
  accessible frameworks as a matter of practicality. Nonetheless,
  the pyTorch project has maintained an aggressive release cadence
  (at least once per quarter year) so new techniques are expected
  to become accessible quickly.

  \section{Methodology}

  \subsection{Overview}
  To attain a systematic analysis of all SID programming techniques
  in the HVSC it must be possible to model and describe these
  techniques and build a kind of DNA database. Tools will be built
  to gather the DNA along with metadata from where and when it
  originated, and then enable comparison and sequencing (in
  the sense of determining the effect of a given DNA sequence).

  As raw DNA, the HVSC includes metadata with each performance,
  including composer names and release dates (where known), and some
  advisory metadata for a SID player program about how to play the
  performance, packaged together as a SID file. These metadata
  includes what model of SID chip(s) to use, whether to use timer
  based playback (see below) etc. A SID file therefore is a complete
  machine language program that produces sound when played.

  \subsection{Playroutines}
  A machine language program, or performance, that programs the SID
  chip to produce sound has been described as a playroutine.  The
  playroutine may be the only program running (such as in a SID file)
  or it may be cooperatively integrated within another program (for
  example, a game). Since a playroutine is in the form of a Turing
  complete computer program it can conceivably take any arbitrarily
  complex form. However, a common form represented in the HVSC is
  interrupt driven (a programmable timer triggers an interrupt at some
  regular interval, which in turn triggers the playroutine to write
  changes to the SID chip).

  The thesis will use the term playroutine to represent any machine
  code used to program the SID chip whether timer based or not, to
  distinguish that code from other code the computer may be running at
  the same time (as part of a game or other integrated performance).

  \subsection{Register logging}
  The most fundamental data upon which the analysis will be based,
  are changes in state (register modifications) of the SID chip. The
  approach will be to use decompilation tools that intercept all calls
  between a playroutine and an emulated SID chip. A performance can
  therefore be represented as a time ordered list of calls, where each
  call is defined as a 4-tuple. The following table consists of 3 calls.

    \begin{tabular}{|c|c|c|c|}
        \hline
        \rule[-1ex]{0pt}{2.5ex} Time Diff & Chip No & SID Register & Value \\
        \rule[-1ex]{0pt}{2.5ex} (cycles) & & (0-28) & (0-255) \\
        \hline
        \rule[-1ex]{0pt}{2.5ex} 0 & 0 & 24 & 15 \\
        \hline
        \rule[-1ex]{0pt}{2.5ex} 16 & 0 & 0 & 8 \\
        \hline
        \rule[-1ex]{0pt}{2.5ex} 8 & 0 & 1 & 1 \\
        \hline
        \rule[-1ex]{0pt}{2.5ex} ... & ... & ... & ... \\
        \hline
    \end{tabular}

  The sequence and content of the calls contain the ``patch''
  information (how a voice is being manipulated - for example
  switching from a pulse waveform to a noise waveform within 20ms, to
  produce a percussive sound, as well as score information over a
  longer time scale (for repeated subsequences producing percussive
  sounds at regular intervals).

  \subsection{Voice 3 feedback}
  The register log depends upon the SID chip being programmed as a
  write-only device, where the order of changes is significant, but
  the performance is not directly aware of the SID chip's audio output
  in real time.

  However, unlike the other voices, voice 3's accumulator state can be
  read from a dedicated 16 bit register. This allows a playroutine to use
  this state as part of further signal processing or synthesis
  techniques. For example, this state could be entered into a delay
  line or queue, and translated into 4 bit digital sample to be played
  back via the volume register as delay effect.

  It will therefore be necessary to include voice 3's accumulator
  state in the register log (see above), along with an additional
  field indicating if and where the machine code has inspected this
  state, to enable further analysis of this technique.

  \subsection{VICE emulator logging modifications}
  The VICE emulator provides a debugging ``dump'' function that
  produces logs in the above format, except for the chip number
  (VICE is modified to add this).  The output is post processed
  to remove redundant state (see below).  It will also be
  necessary to add voice 3 state as above.

  \subsection{Sequence segmentation}
  The fundamental analysis technique for the thesis is
  is the segmentation of sub sequences of SID register calls at
  enumerated intervals within the sequence accomplishing an entire
  performance. Then, identifying repeated sequences and variations and
  comparing sequences across many thousands of performances.

  There are several anticipated stages in segmentation. It assumed
  that for a given SID chip (emulated or otherwise) initialized to the
  same state, that the same sequence of instructions will result in
  the same output. This assumption will need to be verified throughout
  as if not correct would invalidate comparison. It is also expected
  that a set of different sequences may result in the same audio
  output, so there may be a many to one relationship for a given audio
  output.

  \subsection{Redundant state}
  It follows also that there may be sequences that produce no change
  in audio output (for example, repeatedly writing the same value to a
  frequency register, or writing a value to a register with less than
  8 significant bits). These sequences can be eliminated because by
  definition their significance is inaudible.

  Depending on the machine code making the SID register calls, there
  may be variation in the time taken between individual items in a
  sequence (for example, one playroutine might take longer to calculate a
  new frequency value than another using a different algorithm, even
  though both playroutines end up calculating the same value). This
  difference may or may not be audible. A threshold will have to be
  defined (for example, if SID register changes are accomplished
  within one audio sample time at 44.1kHz no difference would be
  observed).  Nonetheless, verification of the significance (or non
  significance) of small differences in timing between the same
  register calls will be required.

  \subsection{Voice multiplexing}
  The SID chip has 3 voices, which can be configured in pairs for some
  FM effects. A given voice may only be paired with a fixed choice of
  one other (for example, voices 1 and 3 are paired). Due to the very
  small number of voices available composers made extensive use of
  multiplexing, for example executing a percussion sound sequence on
  voice 1, then executing a simple pulse wave on voice 1 while
  executing the same percussion sound sequence on voice 2. It is
  assumed that all single voices are interchangeable, and that all
  voice pairs are interchangeable, assumptions that must be verified.

  Aside from the voices, the SID chip has programmable filters and a 4
  bit volume register. All voices are affected by the volume register
  and can be selectively routed to the filters. There is therefore
  another kind of sequence state to be considered, individual voice
  states paired with a specific filter and volume state. These
  combinations must be modeled for comparison.

  \subsection{ADSR envelope bugs}
  One of the SID chip's most documented flaws is a non-deterministic
  ADSR envelope. How the envelope operates upon triggering depends
  upon its state (which phase it was in with what configuration) when
  it was last triggered, unless enough time has passed to cause the
  envelope's accumulator state to return to its initialized state.
  This requires careful management by the composer of ADSR and voice
  state to ensure the the envelope operates, otherwise some envelope
  phases may be skipped or truncated causing undesired artifacts. As
  these management techniques are expressed in precisely timed
  register changes they are captured in the register logging model.

  \subsection{SID Sound Fragment}
  Given the SID has an envelope per voice, a convenient way to model
  a patch is from the envelope being triggered (when the GATE bit
  is set to 1). This distinguishes a new window (potentially encompassing
  many other SID writes, for example changing frequencies or
  waveforms) from a preceding window. This window be described
  as a SID sound fragment. A SSF must include all information
  that could influence the output of a voice (including its
  FM paired voice, and filters).

  \subsection{High/low data rate}
  A wide range of complexity in playroutines is anticipated, from
  very simple, monophonic and mono timbral to extremely
  complex performances incorporating voice 3 feedback, digital
  samples and FM synthesis. It is also anticipated that playroutines
  made be separated broadly into two groups - low data rate (where
  the SID chip is programmed strictly on timer intervals of
  several or perhaps even 10s of milliseconds), and high data rate
  (where SID chip writes are required potentially several times
  per millisecond).

  The high data rate case is expected to be indicative of very
  specific synthesis techniques (such as high resolution samples).
  The low data rate case is expected to be much more common based
  on HVSC's metadata (see SID file format).

    \subsection{Evolution of SID sample playback}
  While the SID chip was not originally specified to include digital
  sample playback, multiple playback methods have been independently
  discovered. These most simple method is using the volume register
  as a 4 bit DAC, while the more complex methods involve using
  multiple voices together to produce higher resolution waveforms
  (sometimes in combination with the volume register). This
  section will include a detailed analysis of the techniques and
  the ancillary techniques (eg. digital signal processing).

  \subsection{SID patch model}
  A common patch description will be required to describe all possible
  SID programming methods, whether low or high data rate. This is
  likely to be a augmented SSF (SID Sound Fragment, see above),
  represented at various levels of optional precision and resolution
  (for example optionally dropping frequency changes, to compare SSFs
  with the same waveform combinations regardless of pitch).

  Tools will be required to translate SSFs into these various forms,
  including to external synthesis software (so that extracted patches
  can verified or re-used in existing C64 synthesis software).

  \subsection{SID patch difference metrics}
  With a generic patch model it will be possible to make comparisons
  in various dimensions, covering cases such as different techniques
  that achieve similar audio output (perhaps indicative of
  independent re-invention). As it is possible to generate audio
  samples from an SSF, it is also possible to ``reverse search'' from
  provided audio samples back to SSFs.

  \subsection{Visualizing complex and patch dissemination}
  With a patch model and varying difference metrics it will be
  possible to produce graphical representations. For example, a
  timeline expressing complexity and introduction of techniques,
  or a directed graph differentiating more common SSF sub-sequences
  versus less common.

  \subsection{Patch programming classification}
  The preceding analysis and visualizations will then support
  a systematic description of each of the distinct programming
  techniques identified and a eludication of their propagation
  over time. Aside from digital synthesis playback such major
  techniques are anticipated to include ADSR envelope
  management and single voice combined waveforms.

  \section{Preliminary work}

  \subsection{Decompilation}
  Basic tools have been assembled (see above) based on the VICE
  emulator to provide scope for the research, and to inform
  the initial SSF/sequencing concept.

  \subsection{sidtableflip}
  An experimental model (sidtableflip) based on the pyTorch framework has been
  developed, that is capable of probablistic prediction of music based on
  register logs, in snippets of 30 to 60s. This model exercises the register
  logging methodology, verifies research platform hardware and software requirements
  (including a dedicated RTX 4090 GPU), and provides a testing method for future
  composer and technique identification techniques.

  sidtableflip is based on pyTorch reference text generator's Transformer
  architecture, with the most significant difference in tokenizing the
  register log - each unique line in the log is a token. A convention in text
  generation models is incorporation of punctuation
  with each word (e.g. assuring "word," and word!" are different tokens with
  their accompanying context.) Since sidtableflip incorporates the time since the last
  register change with each change, effectively including the musical "punctuation"
  in the form of cadence and tempo with each token.

  A 4 layer Transformer with 2 attention heads and 256 embedding dimensions,
  predicting 2048 call sequences, takes approximately 1 day to train over 64 songs,
  comprising a sequence 3 million tokens long with approximately 20000 unique tokens.


  \section{Thesis structure}
  The thesis will be arranged as follows, with an approximate time budget. The bulk of the time
  is anticipated to be spent on the identification of techniques themselves followed by the
  study of how the techniques have evolved and propagated between artists.

  \begin{tabular}{|l|l|l|}
        \hline
        Section & Description & Time budget \\
        \hline
        Introduction &  & 5\% \\
        \hline
        Demoscene culture & The Demoscene and its connection to innovation. & 5\% \\
        \hline
        SID programming & SID hardware and its programming paradigm. & 5\% \\
        \hline
        Methodology & Development of tools and process for SID musicology. & 20\% \\
        \hline
        Composer techniques & Unique techniques and timbres identified. & 25\% \\
        \hline
        Composer identification & Attribution of techniques and their propagation. & 25\% \\
        \hline
        Creative applications & Production of a generative work in collaboration with a Demoscene artist.  & 10\% \\
        \hline
        Conclusion and future work & Summary of the research and potential for further research. & 2.5\% \\
        \hline
        Bibliography/references &  & 2.5\% \\
        \hline
  \end{tabular}

  \subsection{Dessimenation}
  The entire suite of tools used in the research will be open sourced,
  and may take different forms depending on reception by the Demoscene
  community. For example some of the register logging functionality
  may be integrated with the VICE emulator. It is anticipated though
  as a matter of practicality that the majority of tools will be open
  sourced in a small number of repositories with a high level of
  integration and software testing (so that the tools can be easily
  maintained and extended on an ongoing basis beyond the research).
  This open sourcing will facilitate collaboration with Demoscene
  artists and support criticism and improvement of the attribution
  techniques.

  An explicit goal is a collaboration with an artist which may take
  the form of a partially generative performance, and/or a tool that
  enables an artist to identify the use of a particular technique in any
  arbitrary piece of music.

  \subsection{Datasets}
  Aside from performance opportunities that may arise during the
  course of the research, the primary dataset to produced (aside from
  the visualizations described above), together with a tool will
  be machine learning based and will enumerate the relationships
  between a given performance and all other known performances.

\section{Novel contributions and conclusions}

The tools and techniques may be applicable to synthesis platforms
beyond the Commodore 64 (for example, it may be possible to parse
Ableton Live set files at scale, attributing innovation in certain
patch configurations to composers, or to programmatically generate new
set files with machine learning tools).

It may also be possible to apply the techniques to computer
security, for example analyzing BIOS calls for stenographic
activity or the attribution of malware.

Since the Demoscene greatly values recognition of innovation, tools
that automatically identify the earliest use of a given technique,
or even functional equivalence between different techniques may
be appreciated by the community.

\clearpage


\end{multicols*}

\nocite{*}
\bibliographystyle{plain}
\bibliography{sidbasecode_proposal}


\end{document}

% LocalWords:  PCM timeline HVSC Dessimenation Ableton APA citet nzsm
% LocalWords:  programmatically citep phd ADSR
