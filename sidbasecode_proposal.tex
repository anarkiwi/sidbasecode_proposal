\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{lipsum}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{natbib}
\usepackage[font=small]{caption}
\addtolength{\abovecaptionskip}{-3mm}
\addtolength{\textfloatsep}{-5mm}
\setlength\columnsep{20pt}

\usepackage[a4paper,left=1.50cm, right=1.50cm, top=1.50cm, bottom=1.50cm]{geometry}

\author{Josh Bailey <josh@vandervecken.com>}

\title{Sequencing the Chiptune Genome}

\begin{document}

        \begin{center}
          {\Large \textbf{Sequencing the Chiptune Genome}}\\
                \vspace{1em}
                Proposal for Thesis\\
                \vspace{1em}
                \textit{
                Ph.D. Student (Music) - Josh Bailey,
                Student Number: 300665818\\
                  New Zealand School of Music—Te Kōkī,
                  Victoria University of Wellington}\\
                \vspace{1em}
                Supervisors\\
                \vspace{1em}
                \textit{
                  Jim Murphy, Victoria University of Wellington\\
                  Dugal McKinnon, Victoria University of Wellington}\\
        \end{center}

        \begin{center}
                \rule{150mm}{0.2mm}
        \end{center}

        \begin{abstract}
          An early 8 bit home computer, the Commodore 64, contained
          capable sound synthesis hardware for the the period but
          without accompanying software tools.  Composers were
          required to understand the computer's architecture and write
          low level machine code to fully access the sound hardware's
          features. Therefore musical performances such as game
          sound tracks were realized as machine code programs,
          including the ``patches'' (synthesis pipeline configuration
          from moment to moment) and score.

          Over time composers invented new patches and borrowed or
          improved upon the work of others by reverse engineering
          machine code and experimenting with hardware programming
          techniques not anticipated by the manufacturer.  This
          process continues today in the form of a competitive
          ``demoscene'' community.

          It is proposed to make a musicological enumeration and study
          of all known Commodore 64 sound programming techniques,
          attributing the invention of each technique
          and its variations over time, with an approach inspired by
          the analysis of biological DNA.

          This would be done by automating the analysis of a large
          collection of Commodore 64 music in the High Voltage SID
          Collection (over 55,000 performances), with software
          decompilation and reverse engineering tools developed
          specifically for the purpose.

          Beyond the musicological results, machine learning tools
          would be developed to detect the machine language
          programming techniques characteristic of given composers and
          to generate new machine language programs. These tools may
          inform and advance current discussions on the role of
          generative music and attribution of human composers
          contributions to techniques in AI training datasets. While
          the Commodore 64 is a limited platform, its limitations
          facilitate a complete investigation of its capabilities, and
          may inform further research on automated composer
          attribution generally.
        \end{abstract}

        \begin{center}
                \rule{150mm}{0.2mm}
        \end{center}

        \vspace{5mm}

\begin{multicols*}{2}

  \section{Introduction}

  At first glance musicological analysis of Commodore 64 music might
  appear simple as the hardware while long out of production is still
  commonplace today and well documented. The Commodore 64 sound
  hardware (the SID chip) contains features familiar to composers
  today - multiple voices each with a choice of waveform, the ability
  to combine waveforms and voices, and software programmable filters,
  and can be completely programmed through 28, 8 bit registers.

  However, given the lack of built in sound software, the hardware can
  only be fully utilized with 6502 machine code, and the hardware has
  variable performance differences even within the same model number,
  particularly in filter characteristics. While several software and
  hardware emulations of the SID chip exist, the behavior original
  hardware has proven difficult to reproduce exactly and emulator
  defects continue to be discovered.  Therefore analysis must include
  not only methods to work with original hardware, but original
  machine code as well.

  The proposed overall approach is to develop decompilation tools
  that intercept all calls between a machine language program and an
  emulated SID chip. A call is defined as a point in time, a SID
  register, and the value input (or output - see below) to that
  register.

  The sequence and content of the calls contain the ``patch''
  information (how a voice is being manipulated - for example
  switching from a pulse waveform to a noise waveform within 20ms, to
  produce a percussive sound, as well as score information over a
  longer time scale (for repeated subsequences producing percussive
  sounds at regular intervals).

  These sequences are analogous to DNA - a given performance will
  include sequences programmed by a composer, either of their own
  invention (including re-sequencing from another performance that
  might use similar patches), or sequences recovered from the work of
  others.

  These ``DNA'' sequences can then be indexed across all known
  performances, allowing for variation (both variations that produce
  the same audio output, and variations that produce slightly or
  vastly different output depending on the precise order in which they
  are executed). Also like DNA, these sequences can be recombined and
  edited to produce new sequences, compared between sequences, and a
  given subsequence's effect on audio output can be determined.

  \section{Methodology}

  \subsection{Sequence segmentation}

  The fundamental technique upon which the analysis will be performed,
  is the segmentation of sub sequences of SID register calls at
  enumerated intervals within the sequence accomplishing an entire
  performance. Then, identifying repeated sequences and variations
  and comparing sequences across thousands of performances.

  From a first principles perspective, there are several anticipated
  stages in segmentation. It assumed that for a given SID chip
  (emulated or otherwise) initialized to the same state, that the same
  sequence of instructions will result in the same output. This
  assumption will need to be verified throughout as if not correct
  would invalidate comparison. It is also expected that a set of
  different sequences may result in the same audio output, so there
  may be a many to one relationship for a given audio output.

  It follows also that there may be sequences that produce no change
  in audio output (for example, repeatedly writing the same value to a
  frequency register, or writing a value to a register with less than 8
  significant bits). These sequences can be eliminated because by definition
  their significance is inaudible.

  Depending on the machine code making the SID register calls,
  there may be variation in the time taken between individual items in
  a sequence (for example, one program might take longer to calculate
  a new frequency value than another using a different algorithm, even
  though both programs end up calculating the same value). This
  difference may or may not be audible. A threshold will have to be
  defined (for example, if SID register changes are accomplished within
  one audio sample time at 44.1kHz no difference would be observed).
  Nonetheless, verification of the significance (or non significance)
  of small differences in timing between the same register calls
  will be required.

  The SID chip has 3 voices, which can be configured in pairs for some
  FM effects. A given voice may only be paired with a fixed choice of one
  other (for example, voices 1 and 3 are paired). Due to the very small
  number of voices available composers made extensive use of multiplexing,
  for example executing a percussion sound sequence on voice 1, then executing
  a simple pulse wave on voice 1 while executing the same percussion sound
  sequence on voice 2. It is assumed that all single voices are interchangeable,
  and that all voice pairs are interchangeable, assumptions that must be
  verified.

  Aside from the voices, the SID chip has programmable filters and
  a 4 bit volume register. All voices are affected by the volume
  register and can be selectively routed to the filters. There is
  therefore another kind of sequence state to be considered,
  individual voice states paired with a specific filter and volume
  state. These combinations must be modeled for comparison.

  % oscillator state 3 readback for echo

\section{Preliminary work}

\section{Thesis structure, timeline, plan for dissemination}

\section{Novel contributions and conclusions}

Given the constraints of the platform, it should be possible to
comphrensibly enumerate every known SID programming technique as
represented in the HVSC, including attribution of first use of a
technique to a specific performance and composer advancing the
completeness of understanding of the genre and synthesis techniques
within a limited platform.

The tools and techniques may be applicable to synthesis platforms
beyond the Commodore 64 (for example, it may be possible to parse
Abelton Live set files at scale, attributing innovation in certain
patch configurations to composers, or to programmatically
generate new set files with machine learning tools).


%% \subsection{Formatting}

%% All figures and tables that are part of the proposal should fit the page limit. A sample figure is presented in Figure~\ref{fig:fig1}. A sample table that includes how to cite references is presented in Table~\ref{tbl:tbl1}. We do not allow for submission of additional material such as appendices and supplementary materials like data or code.

%% \subsection{Structure}

%% You can use the \texttt{Introduction} section to:

%% \begin{itemize}
%%     \item briefly describe the broad research area of the proposal;
%%     \item the limitations of current research this proposal aims to address;
%%     \item the motivation and impact of the work planned in this research proposal;
%%     \item any additional background required for understanding the proposal.
%% \end{itemize}

%% https://www.hvsc.c64.org/ High Voltage SID Collection %% https://archive.org/details/c64-programmer-ref C64 programmers reference guide
%% https://web.archive.org/web/20221029042239if_/http://archive.6502.org/datasheets/mos_6581_sid.pdf SID datasheet
%% https://github.com/NationalSecurityAgency/ghidra Ghidra
%% https://github.com/anarkiwi/vessel vessel
%% https://github.com/anarkiwi/vap vap
%% https://github.com/c64cryptoboy/ChiptuneSAK

\begin{table*}
        \centering
        \begin{tabular}{cc}
                \hline
                \textbf{Citation format} & \textbf{Citation command} \\
                \hline
                \citet{APA:83} & \textbackslash{}citet{} \\
                \citep{APA:83} & \textbackslash{}citep{} \\
                \hline
        \end{tabular}
        \caption{This is sample table with full page width.}
        \label{tbl:tbl1}
\end{table*}

\begin{figure}[H]
    \centering
        \includegraphics[width=\columnwidth]{example-image}
        \caption{This is a sample figure.}
        \label{fig:fig1}
\end{figure}

\end{multicols*}

\clearpage

\bibliography{nzsm-phd-proposal}
\bibliographystyle{plainnat}

\end{document}
